Networking Pre Study

https://net.cybbh.io/public/networking/latest/index.html

blue space all friendlies, mapping and networkinginto red space which is the opposition.

    ##FUNDAMENTALS

Binary     Hex     Decimal


packets, headers, and their sizes:
32 bits is known as a word
4 bytes make up a word ( 4 bytes in an ip4v address)
first byte in an ip header length is 45
double word 64 bits
quad word 128 bits

if you see base 64 try to decode it
only reason for base 64 here is encode or decode.

Encapsulation and decapsulation

please do not throw sausage pizza way ( pdntspa )

sox proxy is used to maintain and push protocols through an established session
proces includes stripping and adding info to packet header in order to tell where it is going.

Layer 1 PHYSICAL
Layer 2 DATA LINK Layer (arp, vlan, and ethernet)
    -sublayers  (MAC media access control (layer 2 to layer 1) and LLC Logical Link Control)
    -switch looks at just the destination mac to send it out faster only looking at 6 bytes compared to looking at 14 bytes ( cut through forwarding)
  -if you see hex dd hex ipv6, if you see hex 8100 it will be standard vlan tag, hex 88a8 nonstandard vlan tag 

arp used for ip to mac
proxy arp - if router has ip address then router will respond with its mac address
gratuitous arp attack - poison arp cache by sending out a specific malicious host repetitively till something is sent back.
Command: arp -a (shows arp cache) or 'ip neighbor'

IPV4 Header:
DSCP field determines what type of traic it is such as voice (ECN field at tht end is meant for traffic congestion)
Value for DSCP field is the normal value times 4
linux 64
windows 128
cisco 254

Fragmentation Process:
RES DF MF |   Offset
offset changes by taking the data value and divding by 8
for the value defragged will keep adding for what the main value was divided by 

IPV6 Header:

trafic class portion is similar to the dscp field
flow level will tell the which packets need to stay on the same path such as high priority information
hop limit is the same thing as ttl

ICMP Header:

all part of layer 3


Zero Configuration Networking:

Ipv4 auto configuration
-APIPA
-RFC 3927 
IPv6 auto ocnfiguration
-SLAAC (stateless address auto-config)
-RFC 4862

Transport Layer (4):

TCP and UDP

TCP Flags :
CWR, ECE, URG, ACK, PSH, RST, SYN, FIN
Collection of Exceptionally Unskilled Attackers Pester Real Security Folks
(Three Way Handshake)

UDP Headers:

Source, destination, length, checksum each 16 bits
no standardized response through udp
Femeral ports: femeral high port means temporrily open ( short lived only open the amount of time you need to use them)

Session Layer(5):
Socks, NetBIOS, PPTP/L2TP, RPC
                    ^
                VPN Protocol
Socks is used for client server exchange messages

Presentation Layer(6):
translation, formating, encoding, encryption, compression
This layer is for providing information to the user or system in order to coherently run things.



S. IP = 192.168.14.2

filter for source ip 

ip[2:4] = "192.168.14.2"

ip[2:4] = 0xC0 0xA8 0x0E 0x02

ip src = 192.168.14.2

answer: ip[12:4] & 0xFFFFFFFF = 0xC0A80E02

Layer 2 switching technologies:

switch operation: 
fast forward ( only destination MAC ), fragment free( First 64 bytes ), store and forward( Entire Frame and FCS )

Fast Forward is most commonly seen

CAM TABLE 

IEEE 802.1AD "Q-in-Q"
double tagging  0x88A80002                 followed by  \    0x81000064
non standard double tagging 0x91000002     followed by  /

Spanning tree protocol:
Root descision process

1. elect root bridge
2. identify the root ports on non root bridge
3. identify the designated port for each segment
4. set alternate ports to blocking gate

helps with a broadcast storms hitting all switches causing duplicate packets being forwarded out of every port.
'one packet forwared till switches crash'
spanning tree protocol doesnt allow this forwarding
ports going to the router are brute ports.

Layer 2 discovery protocols:
cisco discovery protocol (CDP)
foundry discovery protocol (FDP)
link layer discovery protocol(LLDP)

DTP dynamic trunking protocol:
different kinds of switch ports (access port and trunk port)
trunk ports: help switches transmit vlans to each other, are for devices that need to be aware of vlans being passed. not typically hosts
access ports: hosts have access ports, dont need to know their part of a vlan

switches for ease of use want devices to automatically configure themselves which is why you would use dynamic trunking protocol

Vlan Trunking Protocol:
allows one switch to act as server and passes all info to it. passes out updates.

Port security:
modes: shutdown, restrict, protect

Layer 3 routing technologies:

routers switch broadcast domains
routing table is a table of networks it knows where to send routing info to

First hop redundancy protocols

RFC: white paper about howa protocol works. (standardized throughout the industry) (like syslog and how that protocol works)

Administrative distance
-how routers rank the trustworthiness of a route (the higher the ranking the more trust)

Static routing: literally putting in you get ot such and such network through a given host out of a given port (have to setup oth sides of it)
advantages: no update sent, no bandwidth to use, data path is predetermined
disadvantages: time consuming, administrator must intervene to fix, does not scale for large networks

Dynamic routing: different kinds of routing protocols, typically see distance vector (how far does this traffic have to travel) (Ripv2 EIGRP)
advantages: easy to configure automatically provide updates, intervention not needed, scales very well

IGP and EGP:
BGP uses autanomous systems
border router in between to translate data

IANA world system through internet breaks up into different terrains such as ARIN (U.S. IP's)

IEEE controls creation of protocols we typically use lan wifi ethernet etc...

Link state convergence determines the best path to follow and everything goes with that compared to distcne vecotr where not every router knows every route.
link state they all commnicate with each other and deterine the best path and state.

BGP:
road map of the internet
routes between an AS
only cares about shorter routes

can cause bgp hijacking for illegitimate advertsiing of addresses.

BGP encryption and find hijacking by change of ttl of incoming packets has occured. 23 hops becomes 5 hops is suspicious.

COMMANDS:

To view your IP address and interface information:
        a. current =        ip address (ip addr)
        b. deprecated =     ifconfig

    2. To view your ARP cache:
        a. current =        ip neighbor (ip nei)
        b. deprecated =     arp -a

    3. To view open TCP and UDP sockets:
        a. current = 
            i. TCP =        ss -antlp
            ii. UDP =       ss -anulp
        b. deprecated =     netstat

    4. To view active processes:
        a. static =         ps -elf
        b. real-time =      top or htop

    5. To open file manager from the command line or X11 connection:
        a. nautilus
        b. pcmanfm

    6. Web Browsers:
        a. Firefox
        b. Chromium
        c. Konqueror

    7. To open images from the command line or X11 connection:
        a. Eye of Gnome =                   eog [file]
        b. Nomacs =                         nomacs [file]
        c. Eye of Mate =                    eom [file]
        d. GNU Image Manipulation Program = gimp [file]

    8. Network scanning:
        a. nmap
            -sT = TCP Full connection
            -sS = TCP SYN scanning
            -Pn = Disable ping sweep
            -sU = UDP scanning
        b. zenmap
        c. netcat
            TCP: nc -nzvw1 10.10.0.40 21-23 80
            UDP: nc -unzvw1 10.10.0.40 53 69
        d. ping
        e. traceroute

    9. Network Utilization:
        a. iftop
        b. iptraf-ng

    10. Packet Manipulation (requires root privileges):
        a. scapy
        b. hping3
        c. yersinia     yersinia -G

    11. Packet Sniffing (requires root privileges):
        a. Wireshark
        b. tcpdump
        c. p0f
        d. tshark

    12. Banner Grabbing:
        a. netcat
            Client: nc 10.10.0.40 22
            Listener: nc -lvp 1234
        b. telnet
            telnet 10.10.0.40
        c. wget
            wget -r http://10.10.0.40
            wget -r ftp://10.10.0.40
        d. curl
            curl http://10.10.0.40
            curl ftp://10.10.0.40

    13. DNS Query:
        a. whois
        b. dig
            Records:
                A - IPv4
                AAAA - IPv6
                NS - Name Server
                SOA - Start of Authority
                MX - Mail Server
                TXT - Human readable message

    14. Remote access:
        a. ssh
            ssh student@10.10.0.40
            ssh student@10.10.0.40 -p 2222
        b. telnet
            telnet 10.10.0.40
            telnet 10.10.0.40 23

    15. File Transfer:
        a. scp
            scp student@10.10.0.40:file .
            scp file student@10.10.0.40:
        b. netcat
            nc 10.10.0.40 1234 < file
            nc -lvp 1234 > file


##PACKET CREATION AND SOCKET COMMUNICATION

Different kinds: 
stream sockets: connection oriented data (pcp)
datagram socets: connectionless (udp)
raw sockets: crafting all headers you need putting data directly on the wire (sending very specific data)

* sockets arent just for networking

User Space Sockets -system calls

        -Stream Sockets

        -Datagram Sockets

Kernel Space Sockets -operate directly with hardware (commonly require sudo with the run access permission)

        -Raw Sockets

PYTHON##
Libraries
-import socket
  s = socket.socket(socket.FAMILY, socket.TYPE, socket.PROTOCOL)
        socket.socket([*family*[,*type*[*proto*]]])
        family constants should be: AF_INET (default), AF_INET6, AF_UNIX    

        type constants should be: SOCK_STREAM (default), SOCK_DGRAM, SOCK_RAW

        proto constants should be: 0 (default), IPPROTO_RAW

import socket

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
#this can also be accomplished by using s = socket.socket() due to AF_INET and SOCK_STREAM being defaults

ipaddr = '127.0.0.1'
port = 54321

s.connect((ipaddr, port))

# to send a string as a bytes-like object, add the prefix b to the string. \n is used to go to the next line. (Like hitting enter)
s.send(b'Hello\n')

# It is recommened that the buffer size used with recvfrom is a power of 2 and not very large
response, conn = s.recvfrom(1024)

#in order to receive a message that is sent as a bytes-like object, you must decode it into UTF-8 (default)
print (response.decode())


s.close()


DATAGRAM SOCKET

import socket

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

ipaddr = '127.0.0.1'
port = 54321

s.sendto(b'Hello\n', (ipaddr, port))

response, conn = s.recvfrom(1024)

print(response.decode())

##RAW SOCKET

import socket

# for system level cvommands
import sys

# lib for establishing packet structure (allows direct access)

from struct import *

# create socket

try:
        sys.exit()
        s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)

except socket.error as msg:
        print(msg)

packet = ''

src_ip = '10.0=1.0.2'
dst_ip = '10.3.0.2'

# header info

ip_ver_ihl = 69     #decimal conversion of 0x45 for version and IHL
ip_tos = 0          #combination of DSCP and ECN Fields
ip_len = 0          #kernel will fill in the acgtual length of the field
ip_id = 12345       #sets ip id for the packet
ip_frag = 0         #sets ip fragmentation off
ip_ttl = 64         #determines the TTL of the packet when leaving the machine
ip_proto = 16       #set chos protocol. if tcp (6_ or udp (17) additional headers would be required.
ip_check = 0        #kernel will fill in the checksum for the packet
ip_srcadd = socket.inet_aton(src_ip)    #convert src ip to 32 bit binary number
ip_dstadd = socket.inet_aton(dst_ip)    #convert dst ip to 32 bit binary number

ip_header = pack('!BBHHHBBH4s4s', ip_ver_ihl, ip_tos, ip_len, ip_id, ip_frag, ip_ttl, ip_proto, ip_check, ip_srcadd, ip_dstadd)

message = b'This is a message'
packet = ip_header + message

#send packet
s.sendto(packet, (dst_ip, 0))

##RAW TCP SOCKET
import socket

# for doing an array in tcp connection
import array

# for system level cvommands
import sys

# lib for establishing packet structure (allows direct access)

from struct import *

# create socket

try:
    
        s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)

except socket.error as msg:
        print(msg)
        sys.exeit()

packet = ''

src_ip = '10.10.0.40'
dst_ip = '172.16.40.10'

# header info

ip_ver_ihl = 69     #decimal conversion of 0x45 for version and IHL
ip_tos = 0          #combination of DSCP and ECN Fields
ip_len = 0          #kernel will fill in the acgtual length of the field
ip_id = 2020       #sets ip id for the packet
ip_frag = 0         #sets ip fragmentation off
ip_ttl = 64       #determines the TTL of the packet when leaving the machine
ip_proto = 6       #set chos protocol. if tcp (6_ or udp (17) additional headers would be required.
ip_check = 0        #kernel will fill in the checksum for the packet
ip_srcadd = socket.inet_aton(src_ip)    #convert src ip to 32 bit binary number
ip_dstadd = socket.inet_aton(dst_ip)    #convert dst ip to 32 bit binary number

ip_header = pack('!BBHHHBBH4s4s', ip_ver_ihl, ip_tos, ip_len, ip_id, ip_frag, ip_ttl, ip_proto, ip_check, ip_srcadd, ip_dstadd)

# TCP header fields
tcp_src = 54321         #source port
tcp_dst = 1234          #dst port
tcp_seq = 90210           #sequence number
tcp_ack_seq = 30905         #tcp ack sequence number
tcp_data_off = 5        #data offset specifying size of tcp header in 4-byte words
tcp_reserve = 0         #3 reserve and + ns flag in reserve field
tcp_flags = 0           #tcp flags field before bits are turned on
tcp_win = 65535         #maximum allowed window size
tcp_chk = 0             #tcp checksum which will b e calculated later
tcp_urg_ptr = 0         #urgent pointer only if urg flag is set

# combine the tcp offset and reserve fields left shifted 4 bit tcp ofset and reserve field
tcp_off_res = (tcp_data_off << 4) + tcp_reserve

# TCP flags by bit starting from right to left
tcp_fin = 0
tcp_syn = 1
tcp_rst = 0
tcp_psh = 0
tcp_ack = 0
tcp_urg = 0
tcp_ece = 0
tcp_cwr = 0

#combine the tcp flags by left shifting the bit locations and adding the bits together

tcp_flags = tcp_fin + (tcp_syn << 1) + (tcp_rst << 2) + (tcp_psh << 3) + (tcp_ack << 4) + (tcp_urg << 5) + (tcp_ece << 6) + (tcp_cwr << 7)

# The ! in the pck format string means network order
tcp_hdr = pack('!HHLLBBHHH', tcp_src, tcp_dst, tcp_seq, tcp_ack_seq, tcp_off_res, tcp_flags, tcp_win, tcp_chk, tcp_urg_ptr)

user_data = b'Hello Is this hidden?'

#psudo header fields
src_address = socket.inet_aton(src_ip)
dst_address = socket.inet_aton(dst_ip)
reserved = 0
protocol = socket.IPPROTO_TCP
tcp_length = len(tcp_hdr) + len(user_data)

#pack the psudo header and combine with user data
ps_hdr = pack('!4s4sBBH', src_address, dst_address, reserved, protocol, tcp_length)
ps_hdr = ps_hdr + tcp_hdr + user_data

def checksum(data):
        if len(data) %2 != 0:
                data += b'\0'
        result = sum(array.array("H", data))
        result = (result >> 16) + (result & 0xffff)
        result += result >> 16
        return (~result) & 0xffff

tcp_chk = checksum(ps_hdr)

#pack the tcp header to fill in the correct checksum remember checksum is NOT on network byte order
tcp_hdr = pack('!HHLLBBH', tcp_src, tcp_dst, tcp_seq, tcp_ack_seq, tcp_off_res, tcp_flags, tcp_win) + pack('H', tcp_chk) + pack('!H', tcp_urg_ptr)

#combine all the headers and the user data

packet = ip_header + tcp_hdr + user_data

#send the packet

s.sendto(packet, (dst_ip,0))




T2
Hostname: BLUE_DMZ_Host-1
IP: 172.16.1.15
OS: unknown
Creds:unknown
Last Known SSH Port: unknown
PSP: Unknown
Malware: Unknown
Action: Send a Stream Socket Message to this host





























